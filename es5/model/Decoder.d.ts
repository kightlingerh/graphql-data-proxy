import * as E from 'fp-ts/Either';
import { Refinement } from 'fp-ts/function';
import { NonEmptyArray } from 'fp-ts/NonEmptyArray';
import { Option } from 'fp-ts/Option';
import * as D from 'io-ts/Decoder';
import * as G from './Guard';
import { Literal } from './Schemable';
export * from 'io-ts/Decoder';
export declare const fromRefinement: <I, A extends I>(refinement: Refinement<I, A>, expected: string) => D.Decoder<I, A>;
export declare const fromGuard: <I, A extends I>(guard: G.Guard<I, A>, expected: string) => D.Decoder<I, A>;
export declare const literal: <A extends readonly [Literal, ...Literal[]]>(...values: A) => D.Decoder<unknown, A[number]>;
export declare const string: D.Decoder<string, string>;
export declare const number: D.Decoder<number, number>;
export declare const int: D.Decoder<number, G.Int>;
export declare const float: D.Decoder<number, G.Float>;
export declare const boolean: D.Decoder<boolean, boolean>;
export declare const UnknownArray: D.Decoder<Array<unknown>, Array<unknown>>;
export declare const UnknownRecord: D.Decoder<unknown, Record<string, unknown>>;
export declare const fromOption: <I, A>(a: D.Decoder<I, A>) => D.Decoder<I | null | undefined, Option<A>>;
export declare const option: <A>(a: D.Decoder<unknown, A>) => D.Decoder<unknown, Option<A>>;
export declare const fromEither: <IL, IR, L, R>(l: D.Decoder<IL, L>, r: D.Decoder<IR, R>) => D.Decoder<IL | IR, E.Either<L, R>>;
export declare const either: <L, R>(l: D.Decoder<unknown, L>, r: D.Decoder<unknown, R>) => D.Decoder<unknown, E.Either<L, R>>;
export declare const fromMap: <IK extends string | number, IA, K, A>(k: D.Decoder<IK, K>, a: D.Decoder<IA, A>) => D.Decoder<Record<IK, IA>, Map<K, A>>;
export declare const map: <K, A>(k: D.Decoder<unknown, K>, a: D.Decoder<unknown, A>) => D.Decoder<Record<string | number, unknown>, Map<K, A>>;
export declare const fromSet: <I, A>(a: D.Decoder<I, A>) => D.Decoder<I[], Set<A>>;
export declare const set: <A>(a: D.Decoder<unknown, A>) => D.Decoder<unknown[], Set<A>>;
export declare const fromNonEmptyArray: <I, A>(item: D.Decoder<I, A>) => D.Decoder<I[], NonEmptyArray<A>>;
export declare const nonEmptyArray: <A>(item: D.Decoder<unknown, A>) => D.Decoder<unknown, NonEmptyArray<any>>;
