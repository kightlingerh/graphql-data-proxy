import * as E from 'fp-ts/Either';
import { Refinement } from 'fp-ts/function';
import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import { Option } from 'fp-ts/Option';
import * as TE from 'fp-ts/TaskEither';
import * as TD from 'io-ts/TaskDecoder';
export * from 'io-ts/TaskDecoder';
import * as DE from './DecodeError';
import { Literal } from './Schemable';
import * as G from './Guard';
import * as D from './Decoder';
export interface TaskDecoder<I, A> {
    decode: (i: I) => TE.TaskEither<D.DecodeError, A>;
}
export declare type DecodeError = D.DecodeError;
export declare const error: (actual: unknown, message: string) => DecodeError;
export declare const success: <A>(a: A) => TE.TaskEither<DecodeError, A>;
export declare const failure: <A = never>(actual: unknown, message: string) => TE.TaskEither<import("io-ts/lib/FreeSemigroup").FreeSemigroup<DE.DecodeError<string>>, A>;
export declare const fromRefinement: <I, A extends I>(refinement: Refinement<I, A>, expected: string) => TaskDecoder<I, A>;
export declare const fromGuard: <I, A extends I>(guard: G.Guard<I, A>, expected: string) => TaskDecoder<I, A>;
export declare const literal: <A extends readonly [Literal, ...Literal[]]>(...values: A) => TaskDecoder<unknown, A[number]>;
export declare const string: TaskDecoder<string, string>;
export declare const number: TaskDecoder<number, number>;
export declare const int: TaskDecoder<number, G.Int>;
export declare const float: TaskDecoder<number, G.Float>;
export declare const boolean: TaskDecoder<boolean, boolean>;
export declare const UnknownArray: TaskDecoder<Array<unknown>, Array<unknown>>;
export declare const UnknownRecord: TaskDecoder<unknown, Record<string, unknown>>;
export declare const mapLeftWithInput: <I>(f: (input: I, e: import("io-ts/lib/FreeSemigroup").FreeSemigroup<DE.DecodeError<string>>) => import("io-ts/lib/FreeSemigroup").FreeSemigroup<DE.DecodeError<string>>) => <A>(decoder: TD.TaskDecoder<I, A>) => TD.TaskDecoder<I, A>;
export declare const withMessage: <I>(message: (input: I, e: import("io-ts/lib/FreeSemigroup").FreeSemigroup<DE.DecodeError<string>>) => string) => <A>(decoder: TD.TaskDecoder<I, A>) => TD.TaskDecoder<I, A>;
export declare const refine: <A, B extends A>(refinement: (a: A) => a is B, id: string) => <I>(from: TD.TaskDecoder<I, A>) => TD.TaskDecoder<I, B>;
export declare const parse: <A, B>(parser: (a: A) => TE.TaskEither<import("io-ts/lib/FreeSemigroup").FreeSemigroup<DE.DecodeError<string>>, B>) => <I>(from: TD.TaskDecoder<I, A>) => TD.TaskDecoder<I, B>;
export declare const nullable: <I, A>(or: TD.TaskDecoder<I, A>) => TD.TaskDecoder<I | null, A | null>;
export declare const fromType: <P extends Record<string, TD.TaskDecoder<any, any>>>(properties: P) => TD.TaskDecoder<{ [K in keyof P]: import("io-ts/lib/Kleisli").InputOf<"TaskEither", P[K]>; }, { [K_1 in keyof P]: import("io-ts/lib/Kleisli").TypeOf<"TaskEither", P[K_1]>; }>;
export declare const type: <A>(properties: { [K in keyof A]: TD.TaskDecoder<unknown, A[K]>; }) => TD.TaskDecoder<unknown, { [K_1 in keyof A]: A[K_1]; }>;
export declare const fromPartial: <P extends Record<string, TD.TaskDecoder<any, any>>>(properties: P) => TD.TaskDecoder<Partial<{ [K in keyof P]: import("io-ts/lib/Kleisli").InputOf<"TaskEither", P[K]>; }>, Partial<{ [K_1 in keyof P]: import("io-ts/lib/Kleisli").TypeOf<"TaskEither", P[K_1]>; }>>;
export declare const partial: <A>(properties: { [K in keyof A]: TD.TaskDecoder<unknown, A[K]>; }) => TD.TaskDecoder<unknown, Partial<{ [K_1 in keyof A]: A[K_1]; }>>;
export declare const fromArray: <I, A>(item: TD.TaskDecoder<I, A>) => TD.TaskDecoder<I[], A[]>;
export declare const array: <A>(item: TD.TaskDecoder<unknown, A>) => TD.TaskDecoder<unknown, A[]>;
export declare const fromRecord: <I, A>(codomain: TD.TaskDecoder<I, A>) => TD.TaskDecoder<Record<string, I>, Record<string, A>>;
export declare const record: <A>(codomain: TD.TaskDecoder<unknown, A>) => TD.TaskDecoder<unknown, Record<string, A>>;
export declare const fromTuple: <C extends readonly TD.TaskDecoder<any, any>[]>(...components: C) => TD.TaskDecoder<{ [K in keyof C]: import("io-ts/lib/Kleisli").InputOf<"TaskEither", C[K]>; }, { [K_1 in keyof C]: import("io-ts/lib/Kleisli").TypeOf<"TaskEither", C[K_1]>; }>;
export declare const tuple: <A extends readonly unknown[]>(...components: { [K in keyof A]: TD.TaskDecoder<unknown, A[K]>; }) => TD.TaskDecoder<unknown, A>;
export declare const union: <MS extends readonly [TD.TaskDecoder<any, any>, ...TD.TaskDecoder<any, any>[]]>(...members: MS) => TD.TaskDecoder<import("io-ts/lib/Kleisli").InputOf<"TaskEither", MS[keyof MS]>, import("io-ts/lib/Kleisli").TypeOf<"TaskEither", MS[keyof MS]>>;
export declare const intersect: <IB, B>(right: TD.TaskDecoder<IB, B>) => <IA, A>(left: TD.TaskDecoder<IA, A>) => TD.TaskDecoder<IA & IB, A & B>;
export declare const fromSum: <T extends string>(tag: T) => <MS extends Record<string, TD.TaskDecoder<any, any>>>(members: MS) => TD.TaskDecoder<import("io-ts/lib/Kleisli").InputOf<"TaskEither", MS[keyof MS]>, import("io-ts/lib/Kleisli").TypeOf<"TaskEither", MS[keyof MS]>>;
export declare const sum: <T extends string>(tag: T) => <A>(members: { [K in keyof A]: TD.TaskDecoder<unknown, A[K] & Record<T, K>>; }) => TD.TaskDecoder<unknown, A[keyof A]>;
export declare const fromOption: <I, A>(a: TaskDecoder<I, A>) => TaskDecoder<I, Option<A>>;
export declare const option: <A>(a: TaskDecoder<unknown, A>) => TaskDecoder<unknown, Option<A>>;
export declare const fromEither: <IL, IR, L, R>(l: TaskDecoder<IL, L>, r: TaskDecoder<IL, R>) => TaskDecoder<IL | IR, E.Either<L, R>>;
export declare const either: <L, R>(l: TaskDecoder<unknown, L>, r: TaskDecoder<unknown, R>) => TaskDecoder<unknown, E.Either<L, R>>;
export declare const fromMap: <IK extends string | number, IA, K, A>(k: TaskDecoder<IK, K>, a: TaskDecoder<IA, A>) => TaskDecoder<Record<IK, IA>, Map<K, A>>;
export declare const map: <K, A>(k: TaskDecoder<unknown, K>, a: TaskDecoder<unknown, A>) => TaskDecoder<Record<string | number, unknown>, Map<K, A>>;
export declare const fromSet: <I, A>(a: TaskDecoder<I, A>) => TaskDecoder<I[], Set<A>>;
export declare const set: <A>(a: TaskDecoder<unknown, A>) => TaskDecoder<unknown[], Set<A>>;
export declare const fromNonEmptyArray: <I, A>(item: TaskDecoder<I, A>) => TaskDecoder<I[], NonEmptyArray<A>>;
export declare const nonEmptyArray: <A>(item: TaskDecoder<unknown, A>) => TaskDecoder<unknown, NonEmptyArray<any>>;
export declare const lazy: <I, A>(id: string, f: () => TD.TaskDecoder<I, A>) => TD.TaskDecoder<I, A>;
