import * as N from '../node';
export declare function isMap(val: unknown): val is Map<any, any>;
export declare function isArrayNode(node: N.Node): node is N.ArrayNode<any>;
export declare function isOptionNode(node: N.Node): node is N.OptionNode<any>;
export declare function isNonEmptyArrayNode(node: N.Node): node is N.NonEmptyArrayNode<any>;
export declare function isMapNode(node: N.Node): node is N.MapNode<any, any, any, any, any, any>;
export declare function isTypeNode(node: N.Node): node is N.TypeNode<any, any, any, any>;
export declare function isScalarNode(node: N.Node): node is N.ScalarNode<any, any, any, any, any, any>;
export declare function isSumNode(node: N.Node): node is N.SumNode<any, any, any>;
export declare type PrimitiveNode = N.BooleanNode<any, any> | N.FloatNode<any, any> | N.IntNode<any, any> | N.StringNode<any, any> | N.ScalarNode<any, any, any, any, any, any>;
export declare function isPrimitiveNode(node: N.Node): node is PrimitiveNode;
export declare function isNonPrimitiveEntityNode(node: N.Node): boolean;
export declare type WrappedNode = N.ArrayNode<any, any, any> | N.MapNode<any, any, any, any, any, any, any, any> | N.NonEmptyArrayNode<any, any, any> | N.OptionNode<any, any, any>;
export declare type CacheGraphqlNode = PrimitiveNode | WrappedNode | N.TypeNode<any, any, any, any> | N.SumNode<any, any, any, any> | N.SchemaNode<any, any> | N.ScalarNode<any, any, any, any, any, any>;
export declare function isWrappedNode(node: N.Node): node is WrappedNode;
export declare function traverseMapWithKey<K, A, B>(f: (key: K, value: A) => B): (map: Map<K, A>) => Map<K, B>;
export declare const traverseMap: <A, B>(f: (value: A) => B) => (map: Map<unknown, A>) => Map<unknown, B>;
